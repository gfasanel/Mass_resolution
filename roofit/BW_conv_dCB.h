/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/

#ifndef BW_CONV_DCB
#define BW_CONV_DCB

#include "RooAbsPdf.h"
#include "RooRealProxy.h"
#include "RooRealVar.h"
#include "RooGaussian.h"
#include "RooCategoryProxy.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include "TH1F.h"
#include <stdio.h>
#include "Riostream.h" 
#include "RooMath.h" 
#include <math.h> 
#include "TMath.h" 

class RooRealVar;
 
class BW_conv_dCB : public RooAbsPdf {
public:
  BW_conv_dCB() {} ; 
  BW_conv_dCB(const char *name, const char *title,
	      RooAbsReal& _m,
	      RooAbsReal& _mRes,
	      RooAbsReal& _m0,
	      RooAbsReal& _sigma,
	      RooAbsReal& _alphaL,
	      RooAbsReal& _alphaR,
	      RooAbsReal& _nL,
	      RooAbsReal& _nR);
  BW_conv_dCB(const BW_conv_dCB& other, const char* name=0) ;
  virtual TObject* clone(const char* newname) const { return new BW_conv_dCB(*this,newname); }
  inline virtual ~BW_conv_dCB() { }

protected:

  RooRealProxy m ;
  RooRealProxy mRes ;
  RooRealProxy m0 ;
  RooRealProxy sigma ;
  RooRealProxy alphaL ;
  RooRealProxy alphaR ;
  RooRealProxy nL ;
  RooRealProxy nR ;
  
  Double_t evaluate() const ;

private:
  Double_t getBW(Double_t x)const{
    Double_t arg= x - mRes;
    Double_t Gamma=0.06*mRes;
    return 1. / (arg*arg + 0.25*Gamma*Gamma);
  }

  Double_t getdCB(Double_t x)const{
    Double_t t = (x-m0)/sigma;
    Double_t absAlphaL = fabs((Double_t)alphaL);
    Double_t absAlphaR = fabs((Double_t)alphaR);
  
    if (t >= -absAlphaL && t <= absAlphaR) {
      return exp(-0.5*t*t);
    }
    else if (t < -absAlphaL) {
      Double_t a = TMath::Power(nL/absAlphaL,nL)*exp(-0.5*absAlphaL*absAlphaL);
      Double_t b = nL/absAlphaL - absAlphaL;
      return a/TMath::Power(b - t, nL);
    }
    else {
      Double_t a = TMath::Power(nR/absAlphaR,nR)*exp(-0.5*absAlphaR*absAlphaR);
      Double_t b = nR/absAlphaR - absAlphaR;
      return a/TMath::Power(b + t, nR);
    }
  }

  //For tests : Delta*Gauss -> Gauss; Const*Const->Triangular
  Double_t getDelta(Double_t x)const{
    //delta function centered in 0.5
    if(fabs(x -0.5)>0.1){
      return 0.000001;  
    }else{
      return 1;  
    }
  }

  Double_t getGauss(Double_t x)const{
   Double_t c=(x - m0);
   return exp(-0.5*c*c);
  }

  Double_t getConst(Double_t x)const{
    if(x<0 || x>1){
      return 0.000001;  
    }else{
      return 1;  
    }
  }
  
  ClassDef(BW_conv_dCB,1)
 
};
 
#endif
